<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pix</title>
  
  <subtitle>写着玩的</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-09-12T16:17:59.151Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL的隔离级别和锁机制</title>
    <link href="http://example.com/2025/08/25/%E5%85%88%E4%BB%8ESQL%E6%A0%87%E5%87%86%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%BC%80%E5%A7%8B/"/>
    <id>http://example.com/2025/08/25/%E5%85%88%E4%BB%8ESQL%E6%A0%87%E5%87%86%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%BC%80%E5%A7%8B/</id>
    <published>2025-08-25T12:55:00.000Z</published>
    <updated>2025-09-12T16:17:59.151Z</updated>
    
    <content type="html"><![CDATA[<p><strong>from《Database System Concepts》</strong></p><ul><li><strong>可串行化(serializable):</strong> 通常保证可串行化调度。然而，正如我们将要解释的，一些数据库系统对该隔离性级别的实现在某些情况下允许非可串行化执行。</li><li><strong>可重复读(repeatable read):</strong> 只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据。但该事务不要求与其他事务可串行化。例如:当一个事务在查找满足某些条件的数据时，它可能找到一个已提交事务插入的一些数据，但可能找不到该事务插入的其他数据。</li><li><strong>已提交读(read committed):</strong> 只允许读取已提交数据，但不要求可重复读。比如，在事务两次读</li><li><strong>未提交读(read uncommitted):</strong> 允许读取未提交数据。这是SQL允许的最低一致性级别。</li></ul><p>MySQL为了实现这些隔离级别，引入了许多的机制，接下来笔者将会结合每种隔离级别的机制，解释行锁，表锁，间隙锁，next-key-lock这些奇奇怪怪的名称。</p><h3 id="读未提交-Read-Uncommitted"><a href="#读未提交-Read-Uncommitted" class="headerlink" title="读未提交 (Read Uncommitted)"></a>读未提交 (Read Uncommitted)</h3><p>没啥好说的，其实就是啥也不干，一个数据库最基础的样子，当然，为了防止脏写，一个事务在修改某条行数据前，尝试获取这条数据的锁，不然就乱套了。</p><h3 id="读已提交-Read-Committed"><a href="#读已提交-Read-Committed" class="headerlink" title="读已提交 (Read Committed)"></a>读已提交 (Read Committed)</h3><p>事务A只能看到事务B已经提交的修改，那如果B修改了一条行数据，但是就不提交呢，那A只能看到B修改之前的版本，如果B提交了，A就可以看到B修改之后的版本。从实现的角度来说，B必须要能成功修改，A也必须要成功读取，那么只能维护一条数据的已提交版本和未提交版本，其它事务去读取数据时，返回未提交版本，写事务提交时，把未提交版本变成已提交版本。当然，这个写的过程也是要获取行锁的，但也仅此而已。</p><h3 id="可重复读-Repeatable-Read-快照隔离"><a href="#可重复读-Repeatable-Read-快照隔离" class="headerlink" title="可重复读 (Repeatable Read) &#x2F; 快照隔离"></a>可重复读 (Repeatable Read) &#x2F; 快照隔离</h3><p>这是MySQL的默认隔离级别，解决了不可重复读，大部分的幻读问题。</p><p><strong>什么是不可重复读？</strong></p><p>事务A读取了一条行数据，事务B修改这行然后提交，因为没有其它事务去获取这个数据的写锁，B能成功修改，事务A第二次读，读出来的数据和上一次的不一样，这就是不可重复读。</p><p>一种实现方案是加锁，事务A读完这条数据，事务B不能改，很霸道，当然是可以的，但是性能上就不好。</p><p>聪明的你肯定想到另一种方案，版本快照，给每个事务加个ID，给每个数据版本打上事务id的tag，不管后面提交了多少版，事务A只要一直读属于自己的版本就好啦，这也就是MySQL的实现思路。</p><p><strong>什么是幻读？</strong></p><p>考虑一条简单的SQL语句，查找所有年龄大于16的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name </span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设只有学生张三，李四满足该条件，但是在查询的同时，另外一个事务尝试插入一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> student <span class="keyword">values</span>(<span class="string">&#x27;王五&#x27;</span>,<span class="number">19</span>);</span><br></pre></td></tr></table></figure><p>查询结果会因为这条插入语句的执行时机而有所不同。</p><p>有了不可重复读的解决经验在，我们直接给每条数据版本附上事务ID，那查询SQL的结果也可以根据事务ID来过滤，事务A执行了查询，然后事务B插入，事务A再查，结果肯定还是一样的。</p><p>但是，考虑一个这样的场景：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> ... <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>事务</p><p>要解决这个问题，我们要么不让事务B插入这条数据，要么不让A去更新，显然，不让B去插入是更加合理的，因为它破坏了事务A的业务逻辑，这时候我们就需要加锁。由于在这个场景下，事务A和事务B并不是在某个元组上发生冲突，他们并没有访问相同的元组，甚至没有访问到元组，所以行锁在这里是不管用的，我们需要找到它们互相冲突的共同资源，对这个资源加锁。</p><p>在这个场景下，很容易想到是索引，没错，事务A的查询和事务B的插入都需要先访问索引，所以我们可以在索引这里设一道关卡，先把A放过去，然后B再想插入的时候，就会阻塞。</p><p>假设索引是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[16] [19] [25] [40]</span><br></pre></td></tr></table></figure><p>为了阻止B事务新增值为 (18,20) 的节点，我们封锁住索引中16右边，25左边的节点，也就是禁止插入大于16且小于25的节点。</p><p>一个疑问：这样看起来，封锁的范围变大了，我们本来只需要封锁 (18,20)，但是实际上封锁的范围变成了 (16,25)，这其实是一种简便的方案，我们只需要阻止B+Tree的某个叶节点的更新操作，就可以完成基于范围的加锁，这也就是MySQL中的 gap-lock (间隙锁)。</p><p>那 next-key-lock 又是什么？网上大多数文章都说next-key-lock是间隙锁+记录锁，笔者一开始也是一头雾水，其实从解决方案的角度来说，我们在通过索引阻止新记录插入的同时，也需要阻止范围内已有记录的更新，所以要给范围内所有的元组也加上一把写锁，最后就组合成了 next-key-lock 这个奇奇怪怪的名称。其实本质上，记录锁和间隙锁需要同步的资源不同，一个是行记录，一个是基于行记录字段的索引，他们锁的不是同一个地方。</p><p>MySQL为了性能上的考虑，对快照读使用的是多版本方案，也就是不加锁，只有当前读和写操作才会加锁，所以可重复读级别并没有完全的解决幻读，参考：</p><p><a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB">MySQL 可重复读隔离级别，完全解决幻读了吗？</a></p><h3 id="可串行化-Serializable"><a href="#可串行化-Serializable" class="headerlink" title="可串行化 (Serializable)"></a>可串行化 (Serializable)</h3><p>这是数据库系统的终极目标，其它的隔离级别都是为了并发性能而做的不同程度的妥协，主要通过2PL来实现，其实把可重复读级别下所有select换成select for update，那事务就是可串行化的。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>作为MySQL的默认隔离级别，可重复读其实已经是最佳实践，对于写偏斜、幻读问题，开发者其实更应该去评估特定事务的执行逻辑，判断是否有非串行化的风险，适时、灵活的使用快照读和当前读，达成性能与正确性的平衡。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;from《Database System Concepts》&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可串行化(serializable):&lt;/strong&gt; 通常保证可串行化调度。然而，正如我们将要解释的，一些数据库系统对该隔离性级别的</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2023/10/02/hello-world/"/>
    <id>http://example.com/2023/10/02/hello-world/</id>
    <published>2023-10-01T16:00:00.000Z</published>
    <updated>2025-09-12T16:14:59.016Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
