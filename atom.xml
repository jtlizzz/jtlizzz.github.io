<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pix</title>
  
  <subtitle>写着玩的</subtitle>
  <link href="http://username.github.io/atom.xml" rel="self"/>
  
  <link href="http://username.github.io/"/>
  <updated>2025-09-14T08:03:10.557Z</updated>
  <id>http://username.github.io/</id>
  
  <author>
    <name>Pix</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM里的GC机制</title>
    <link href="http://username.github.io/2025/09/14/JVM%E9%87%8C%E7%9A%84GC%E6%9C%BA%E5%88%B6/"/>
    <id>http://username.github.io/2025/09/14/JVM%E9%87%8C%E7%9A%84GC%E6%9C%BA%E5%88%B6/</id>
    <published>2025-09-14T05:22:39.000Z</published>
    <updated>2025-09-14T08:03:10.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GC的目标"><a href="#GC的目标" class="headerlink" title="GC的目标"></a>GC的目标</h2><ul><li>正确性：GC不能回收正在使用的对象</li><li>吞吐量：用户线程占用CPU时间片的比例，越高越好</li><li>低延迟：GC在工作时，可能要暂停所有用户线程，暂停时间越短越好</li><li>低内存开销：为了实现GC而产生的额外内存开销越低越好</li></ul><p>总的来说，在保证正确性的同时，尽可能减少GC对CPU，内存资源的使用，以及对用户线程的阻塞</p><p><em>在GC算法的实现中，有两大流派，引用计数和可达性分析，引用计数由于无法解决循环依赖问题而患有“先天残疾”，大多数带GC的编程语言都采用可达性分析的方法，JAVA也不例外</em></p><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>从一组已知的、无法被回收的对象（GC Roots）出发，遍历所有可达对象，也就是搜索出以GC Roots为起点的对象引用图，不在图中的对象是可以回收的</p><h3 id="快速的根节点枚举"><a href="#快速的根节点枚举" class="headerlink" title="快速的根节点枚举"></a><strong>快速的根节点枚举</strong></h3><p>常量或类静态属性等GC Root的引用位置是可以在类加载期间就确定的，举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">// 在类加载阶段，B引用的位置就已经确定</span></span><br><span class="line">    <span class="comment">// 运行时，B指向什么对象是不确定的，也就是说B里面是什么内容（内存地址是什么），是不确定的</span></span><br><span class="line">    <span class="comment">// 但是B这个引用放在哪，是确定的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比如，在类加载完成之后，0x01中存放了B对象的地址，我们不知道0x01里面存了啥</span></span><br><span class="line"><span class="comment">但是我们知道了0x01一定存着一个对象的引用，所以可以把0x01作为一个扫描的起点</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>而线程的执行上下文中的引用，在代码执行到特定行数之前也是可以确定的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 代码执行到这里时，a,b两个引用的地址会按固定的顺序放进栈帧里面的局部变量表的槽位</span></span><br><span class="line">    <span class="comment">// 我们也可以把这些槽位的内存地址记下来，作为一个扫描的起点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>OopMap</strong>：JAVA用来保存刚刚提到的内存地址的一种数据结构，在GC时，只要获取到当前的OopMap，从OopMap里面开始扫描</p><p>在代码执行的过程中，执行上下文的引用位置并不是一成不变的，如果我们记录了执行完某行代码时的引用位置，当代码继续往后执行时，原来的栈帧可能被弹出，压入新的其它方法的栈帧，这时候我们再根据刚刚保存到位置去扫描，无疑是一种“刻舟求剑”的行为，所以我们需要暂停用户线程。</p><p>这个过程大概是这样的，首先选择一些特定的执行位置，然后计算并保存这个位置的<strong>OopMap</strong>，这是可以预先完成的事情，然后当用户线程运行到这，让它停止，去扫描之前保存好的OopMap，扫描完成之后，放行用户线程。</p><p>所以为了GC，JAVA会在编译or类加载期间做一些额外的事情，分析每一段用户线程可能执行到的代码，选取一些位置，也称作<strong>安全点</strong>，为这些安全点生成OopMap，设置一个标志位，当线程执行到安全点代码时，读取标志位，判断当前是否需要GC，如果是，则自己挂起，等待其它线程挂起，当所有用户线程挂起之后，GC线程读取OopMap中的所有引用，并放进扫描集合，放行用户线程，进入<strong>并发标记</strong>阶段</p><h3 id="可达性分析中的并发（并发标记）"><a href="#可达性分析中的并发（并发标记）" class="headerlink" title="可达性分析中的并发（并发标记）"></a>可达性分析中的并发（并发标记）</h3><p>为了控制停顿时间，垃圾回收器在标记阶段需要和用户线程并发执行，当一个已经扫描的对象增加了新的引用，并且这个这个被引用的对象没有被其它未扫描到的对象引用时（或者原来有引用，但是被删除了），这个对象最后就被误认为垃圾回收掉，这是非常危险的</p><p>当以下两个条件同时被满足，会产生对象消失问题：</p><ul><li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li></ul><p>为了解决这个问题，有两种策略</p><ul><li>增量更新（Incremental Update）</li><li>原始快照（Snapshot At The Beginning，SATB）</li></ul><p><strong>增量更新</strong></p><p>关注第一个条件，为当黑色对象（已经扫过的对象）需要新增一条引用时，记录下来，等并发扫描结束后再扫一次，可以理解为当黑色对象新增一条引用，就把它变成灰色对象（已经被访问，但是引用还没扫完）</p><p><strong>原始快照</strong></p><p>关注第二个条件，当灰色或白色对象需要删除一条引用时，记录下来，在并发扫描结束后，再从这些被删除的引用出发扫描一次，也就是不把它当垃圾</p><p><strong>如果黑色对象在并发标记期间新增了一个引用，这个引用并不存在与灰色&#x2F;白色对象里，怎么处理？</strong></p><p>在增量更新的策略里，这种情况会被记录下来，结束后继续扫描。</p><p>在原始快照的策略里，不会记录这种情况，但是，会将所有并发标记中新建的对象标记为存活。</p><h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><ul><li><p><strong>标记-清除</strong></p><p>  扫一遍，垃圾对象标记为空闲内存</p><p>  缺点：内存碎片</p></li><li><p><strong>标记-整理</strong></p><p>  在标记-清除的基础上，移动存活的对象到内存的固定端，腾出整块的空闲内存</p><p>  缺点：费时间</p></li><li><p><strong>复制</strong></p><p>  把内存分成两半，每次只使用一半，每次gc把存活的对象复制到另一半，然后原来那一半整块都空闲了</p><p>  缺点：内存占用大，如果存活对象多，复制开销也大</p></li></ul><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/8a9db36e.png" alt="传统GC内存布局"></p><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h3><p>大多数对象即用即弃，有些对象需要一直使用，如果每次GC都全堆扫描，那么难以达成吞吐量和性能的平衡。所以要给对象分区，一部分对象需要更频繁的GC，而另外一部分的不用</p><p>新生代：采用复制算法，当Eden区满时，触发一次minorGC，存活下来的对象放到幸存区，幸存区中的老对象则晋升到老年代</p><p>老年代：采用标记-清除或标记整理，当老年代空间不足，触发major GC或full GC</p><h3 id="跨代引用问题"><a href="#跨代引用问题" class="headerlink" title="跨代引用问题"></a><strong>跨代引用问题</strong></h3><p>当只针对一个区域的对象进行GC扫描时，无法分析到区域间的引用关系，比如新生代的某个对象A只被老年代的对象B引用，如果只扫新生代，A会被当成垃圾，但其实不应该回收。</p><p>那怎么办呢，难道再扫一次老年代吗，这违背了分代收集的初衷</p><p>采用记忆集来维护跨代引用关系，老年代的某个对象B如果要引用新生代的对象，那就把B添加到记忆集中，在扫描新生代时，把记忆集里的对象一起扫描了，记忆集的粒度不应该太小，不然内存成本大，也不应该太大，不然扫描成本大，把老年代分块，如果块内有对象引用了新生代，那么就在记忆集里标记一下这个块，扫描这个块里的所有对象</p><h2 id="并发整理"><a href="#并发整理" class="headerlink" title="并发整理"></a>并发整理</h2><p>G1收集器，只是在标记阶段不影响用户线程，但是在整理阶段也是需要暂停用户线程的。因为整理的过程中，存活对象的地址会变化，那么其它对象保存的这个引用是不一定有效的。</p><p>没有什么是加中间层不能解决的，如果有，那就再加一层</p><p>我们只要让 <strong>对象引用（指针）-&gt;对象物理地址</strong> 这个访问操作始终有效，ZGC采用<strong>染色指针+读屏障</strong>解决这个问题</p><p>相较于传统收集器把GC需要的信息放在对象头或者额外的、JVM层面的、数据结构中，ZGC大胆的将GC信息放在对象的指针（地址&#x2F;引用）里，牺牲了一部分的寻址空间，但获得了很多额外的好处</p><p>染色指针的结构</p><p><img src="/images/image-20250906145114266.png" alt="image-20250906145114266"></p><p>ZGC会给所有对象访问操作加一个读屏障，访问前检查remapped位</p><p>如果是0，说明对象指向的是旧地址，读屏障会触发慢速路径，去查转发表，把新地址搬过来，并把remapped置为1</p><p>如果是1，直接访问</p><p>这种旧地址在被访问时替换新地址的过程，被称为<strong>自愈（Self-Healing）</strong></p><p>总的来说，ZGC的清理过程可以分为三步</p><ul><li>并发标记：这里并没有什么创新，和G1，CMS这些差不多，不一样的是ZGC只会改指针的m1,m0位</li><li>并发预备重分配：全堆扫描，选定一批需要整理的页，预先在新页中分配位置，创建转发表</li><li>并发重分配：将对象从旧地址搬到新地址，更新转发表</li><li>并发重映射：也就是修复旧指针，由于读屏障的存在，这并不是一个需要特意去做的过程，在下一次GC扫描过程中，所有指针会自动修复</li></ul><h2 id="发展的里程碑"><a href="#发展的里程碑" class="headerlink" title="发展的里程碑"></a>发展的里程碑</h2><h3 id="Serial-系列"><a href="#Serial-系列" class="headerlink" title="Serial 系列"></a>Serial 系列</h3><p>分代的，单线程的，全程（GC线程运行时）STW的收集器，看起来很老旧落后，但是相较于其它的收集器，有更小的额外内存占用，因此，在用户桌面的应用场景以及流行的微服务，云原生场景中，仍有一席之地</p><h3 id="Parallel-系列"><a href="#Parallel-系列" class="headerlink" title="Parallel 系列"></a>Parallel 系列</h3><p>相较于Serial 系列，引入了多线程，也就是GC过程中，有多个GC线程一起工作，但这个过程仍然需要暂停用户线程，Parallel 还提供了一些调优参数，可以主动设置最大停顿时间和吞吐量</p><h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>相较于前辈，引入了<strong>并发标记</strong>，在标记阶段不需要暂停用户线程，并发标记完成之后为了修正结果（并发标记阶段产生的不一致问题），会有一次STW，然后就是清除，因为CMS用的是<strong>标记-清除</strong>算法，不会影响用户进程，所以这个阶段也是并发的。</p><p>由于它的标记-清除策略，会产生很多内存碎片，当内存碎片太多，新对象塞不下时，则会来一次Full GC，<strong>标记-整理</strong>全堆，造成长时间的停顿，这也是CMS饱受诟病的原因</p><h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>Oracle的一小步，GC发展的一大步，开创了基于Region的内存布局形式，全堆收集，引入停顿时间预测模型，支持用户自定义停顿时间，每次GC通过“贪心算法”选择最有价值的Region回收，随着不断迭代，现在的G1在各种场景下性能表现均优于CMS，已经成为新版本JDK中默认的收集器</p><h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>GC的前沿成果，实现了<strong>并发整理</strong>，有着超低的延迟，相较于前辈是<strong>数量级</strong>的差异，同时，吞吐量也毫不逊色，尤其在JDK21中，ZGC还引入了分代收集，可以说是未来的方向。</p><p><img src="/images/image-20250914152829967.png" alt="image-20250914152829967"></p><p><img src="/images/image-20250914152855867.png" alt="image-20250914152855867"></p><p>上图来自<a href="https://cr.openjdk.org/~pliden/slides/ZGC-Jfokus-2018.pdf">《The Z Garbage Collector：Low Latency GC for OpenJDK》</a>比较了三款收集器的吞吐量和延迟</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;GC的目标&quot;&gt;&lt;a href=&quot;#GC的目标&quot; class=&quot;headerlink&quot; title=&quot;GC的目标&quot;&gt;&lt;/a&gt;GC的目标&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;正确性：GC不能回收正在使用的对象&lt;/li&gt;
&lt;li&gt;吞吐量：用户线程占用CPU时间片的比例，越高越好&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL的隔离级别和锁机制</title>
    <link href="http://username.github.io/2025/08/25/%E5%85%88%E4%BB%8ESQL%E6%A0%87%E5%87%86%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%BC%80%E5%A7%8B/"/>
    <id>http://username.github.io/2025/08/25/%E5%85%88%E4%BB%8ESQL%E6%A0%87%E5%87%86%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%BC%80%E5%A7%8B/</id>
    <published>2025-08-25T12:55:00.000Z</published>
    <updated>2025-09-13T01:06:58.058Z</updated>
    
    <content type="html"><![CDATA[<p><strong>from《Database System Concepts》</strong></p><ul><li><strong>可串行化(serializable):</strong> 通常保证可串行化调度。然而，正如我们将要解释的，一些数据库系统对该隔离性级别的实现在某些情况下允许非可串行化执行。</li><li><strong>可重复读(repeatable read):</strong> 只允许读取已提交数据，而且在一个事务两次读取一个数据项期间，其他事务不得更新该数据。但该事务不要求与其他事务可串行化。例如:当一个事务在查找满足某些条件的数据时，它可能找到一个已提交事务插入的一些数据，但可能找不到该事务插入的其他数据。</li><li><strong>已提交读(read committed):</strong> 只允许读取已提交数据，但不要求可重复读。比如，在事务两次读</li><li><strong>未提交读(read uncommitted):</strong> 允许读取未提交数据。这是SQL允许的最低一致性级别。</li></ul><p>MySQL为了实现这些隔离级别，引入了许多的机制，接下来笔者将会结合每种隔离级别的机制，解释行锁，表锁，间隙锁，next-key-lock这些奇奇怪怪的名称。</p><h3 id="读未提交-Read-Uncommitted"><a href="#读未提交-Read-Uncommitted" class="headerlink" title="读未提交 (Read Uncommitted)"></a>读未提交 (Read Uncommitted)</h3><p>没啥好说的，其实就是啥也不干，一个数据库最基础的样子，当然，为了防止脏写，一个事务在修改某条行数据前，尝试获取这条数据的锁，不然就乱套了。</p><h3 id="读已提交-Read-Committed"><a href="#读已提交-Read-Committed" class="headerlink" title="读已提交 (Read Committed)"></a>读已提交 (Read Committed)</h3><p>事务A只能看到事务B已经提交的修改，那如果B修改了一条行数据，但是就不提交呢，那A只能看到B修改之前的版本，如果B提交了，A就可以看到B修改之后的版本。从实现的角度来说，B必须要能成功修改，A也必须要成功读取，那么只能维护一条数据的已提交版本和未提交版本，其它事务去读取数据时，返回未提交版本，写事务提交时，把未提交版本变成已提交版本。当然，这个写的过程也是要获取行锁的，但也仅此而已。</p><h3 id="可重复读-Repeatable-Read-快照隔离"><a href="#可重复读-Repeatable-Read-快照隔离" class="headerlink" title="可重复读 (Repeatable Read) &#x2F; 快照隔离"></a>可重复读 (Repeatable Read) &#x2F; 快照隔离</h3><p>这是MySQL的默认隔离级别，解决了不可重复读，大部分的幻读问题。</p><p><strong>什么是不可重复读？</strong></p><p>事务A读取了一条行数据，事务B修改这行然后提交，因为没有其它事务去获取这个数据的写锁，B能成功修改，事务A第二次读，读出来的数据和上一次的不一样，这就是不可重复读。</p><p>一种实现方案是加锁，事务A读完这条数据，事务B不能改，很霸道，当然是可以的，但是性能上就不好。</p><p>聪明的你肯定想到另一种方案，版本快照，给每个事务加个ID，给每个数据版本打上事务id的tag，不管后面提交了多少版，事务A只要一直读属于自己的版本就好啦，这也就是MySQL的实现思路。</p><p><strong>什么是幻读？</strong></p><p>考虑一条简单的SQL语句，查找所有年龄大于16的学生：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> name </span><br><span class="line"><span class="keyword">from</span> student</span><br><span class="line"><span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>假设只有学生张三，李四满足该条件，但是在查询的同时，另外一个事务尝试插入一条记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert into</span> student <span class="keyword">values</span>(<span class="string">&#x27;王五&#x27;</span>,<span class="number">19</span>);</span><br></pre></td></tr></table></figure><p>查询结果会因为这条插入语句的执行时机而有所不同。</p><p>有了不可重复读的解决经验在，我们直接给每条数据版本附上事务ID，那查询SQL的结果也可以根据事务ID来过滤，事务A执行了查询，然后事务B插入，事务A再查，结果肯定还是一样的。</p><p>但是，考虑一个这样的场景：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务A</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> ... <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务B</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> student <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="number">18</span> <span class="keyword">and</span> age <span class="operator">&lt;</span> <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>事务</p><p>要解决这个问题，我们要么不让事务B插入这条数据，要么不让A去更新，显然，不让B去插入是更加合理的，因为它破坏了事务A的业务逻辑，这时候我们就需要加锁。由于在这个场景下，事务A和事务B并不是在某个元组上发生冲突，他们并没有访问相同的元组，甚至没有访问到元组，所以行锁在这里是不管用的，我们需要找到它们互相冲突的共同资源，对这个资源加锁。</p><p>在这个场景下，很容易想到是索引，没错，事务A的查询和事务B的插入都需要先访问索引，所以我们可以在索引这里设一道关卡，先把A放过去，然后B再想插入的时候，就会阻塞。</p><p>假设索引是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[16] [19] [25] [40]</span><br></pre></td></tr></table></figure><p>为了阻止B事务新增值为 (18,20) 的节点，我们封锁住索引中16右边，25左边的节点，也就是禁止插入大于16且小于25的节点。</p><p>一个疑问：这样看起来，封锁的范围变大了，我们本来只需要封锁 (18,20)，但是实际上封锁的范围变成了 (16,25)，这其实是一种简便的方案，我们只需要阻止B+Tree的某个叶节点的更新操作，就可以完成基于范围的加锁，这也就是MySQL中的 gap-lock (间隙锁)。</p><p>那 next-key-lock 又是什么？网上大多数文章都说next-key-lock是间隙锁+记录锁，笔者一开始也是一头雾水，其实从解决方案的角度来说，我们在通过索引阻止新记录插入的同时，也需要阻止范围内已有记录的更新，所以要给范围内所有的元组也加上一把写锁，最后就组合成了 next-key-lock 这个奇奇怪怪的名称。其实本质上，记录锁和间隙锁需要同步的资源不同，一个是行记录，一个是基于行记录字段的索引，他们锁的不是同一个地方。</p><p>MySQL为了性能上的考虑，对快照读使用的是多版本方案，也就是不加锁，只有当前读和写操作才会加锁，所以可重复读级别并没有完全的解决幻读，参考：</p><p><a href="https://xiaolincoding.com/mysql/transaction/phantom.html#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%BB%E8%AF%BB">MySQL 可重复读隔离级别，完全解决幻读了吗？</a></p><h3 id="可串行化-Serializable"><a href="#可串行化-Serializable" class="headerlink" title="可串行化 (Serializable)"></a>可串行化 (Serializable)</h3><p>这是数据库系统的终极目标，其它的隔离级别都是为了并发性能而做的不同程度的妥协，主要通过2PL来实现，其实把可重复读级别下所有select换成select for update，那事务就是可串行化的。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>作为MySQL的默认隔离级别，可重复读其实已经是最佳实践，对于写偏斜、幻读问题，开发者其实更应该去评估特定事务的执行逻辑，判断是否有非串行化的风险，适时、灵活的使用快照读和当前读，达成性能与正确性的平衡。  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;from《Database System Concepts》&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;可串行化(serializable):&lt;/strong&gt; 通常保证可串行化调度。然而，正如我们将要解释的，一些数据库系统对该隔离性级别的</summary>
      
    
    
    
    
  </entry>
  
</feed>
