<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>JVM里的GC机制 | Pix</title>
  
    <link rel="icon" href="/assets/favicon.svg">
  
  
  
  <!--link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css"-->
  
<link rel="stylesheet" href="//cdn.jsdelivr.net/highlight.js/9.10.0/styles/github-gist.min.css">

  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="Pix" type="application/atom+xml">
</head>

<body>
<div class="Shell">
    <aside class='SideBar'>
    <section class='avatar' style="background-image: url()">
        <div class='av-pic' style="background-image: url(/assets/avatar_.png)">
        </div>
    </section>
    <section class='menu'>
        <div>Pix</div>
        
            <div>写着玩的</div>
        
        <ul>
          
            <a href="/" class="Btn">
              <li>Home</li>
            </a>  
          
            <a href="/archives/" class="Btn">
              <li>Archive</li>
            </a>  
          
        </ul>
    </section>
    <section class="media">
        
            
                <a target="_blank" rel="noopener" href="https://github.com/jtlizzz">
                    <img src="/assets/github.svg" />
                </a>
            
        
            
                <a href="mailto:jtli.dev@qq.com">
                    <img src="/assets/email.svg" />
                </a>
            
        
            
                <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/limon-62-39">
                    <img src="/assets/zhihu.svg" />
                </a>
            
        
    </section>
</aside>

    <div class="container">
        <div data-pager-shell>
            <div>
  <article class='ContentView'>
    <header class='PageTitle'>
        <h1>JVM里的GC机制</h1>
    </header>

    <section>
      <h2 id="GC的目标"><a href="#GC的目标" class="headerlink" title="GC的目标"></a>GC的目标</h2><ul>
<li>正确性：GC不能回收正在使用的对象</li>
<li>吞吐量：用户线程占用CPU时间片的比例，越高越好</li>
<li>低延迟：GC在工作时，可能要暂停所有用户线程，暂停时间越短越好</li>
<li>低内存开销：为了实现GC而产生的额外内存开销越低越好</li>
</ul>
<p>总的来说，在保证正确性的同时，尽可能减少GC对CPU，内存资源的使用，以及对用户线程的阻塞</p>
<p><em>在GC算法的实现中，有两大流派，引用计数和可达性分析，引用计数由于无法解决循环依赖问题而患有“先天残疾”，大多数带GC的编程语言都采用可达性分析的方法，JAVA也不例外</em></p>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>从一组已知的、无法被回收的对象（GC Roots）出发，遍历所有可达对象，也就是搜索出以GC Roots为起点的对象引用图，不在图中的对象是可以回收的</p>
<h3 id="快速的根节点枚举"><a href="#快速的根节点枚举" class="headerlink" title="快速的根节点枚举"></a><strong>快速的根节点枚举</strong></h3><p>常量或类静态属性等GC Root的引用位置是可以在类加载期间就确定的，举个栗子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="comment">// 在类加载阶段，B引用的位置就已经确定</span></span><br><span class="line">    <span class="comment">// 运行时，B指向什么对象是不确定的，也就是说B里面是什么内容（内存地址是什么），是不确定的</span></span><br><span class="line">    <span class="comment">// 但是B这个引用放在哪，是确定的</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">比如，在类加载完成之后，0x01中存放了B对象的地址，我们不知道0x01里面存了啥</span></span><br><span class="line"><span class="comment">但是我们知道了0x01一定存着一个对象的引用，所以可以把0x01作为一个扫描的起点</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>而线程的执行上下文中的引用，在代码执行到特定行数之前也是可以确定的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="type">Object</span> <span class="variable">b</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="comment">// 代码执行到这里时，a,b两个引用的地址会按固定的顺序放进栈帧里面的局部变量表的槽位</span></span><br><span class="line">    <span class="comment">// 我们也可以把这些槽位的内存地址记下来，作为一个扫描的起点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>OopMap</strong>：JAVA用来保存刚刚提到的内存地址的一种数据结构，在GC时，只要获取到当前的OopMap，从OopMap里面开始扫描</p>
<p>在代码执行的过程中，执行上下文的引用位置并不是一成不变的，如果我们记录了执行完某行代码时的引用位置，当代码继续往后执行时，原来的栈帧可能被弹出，压入新的其它方法的栈帧，这时候我们再根据刚刚保存到位置去扫描，无疑是一种“刻舟求剑”的行为，所以我们需要暂停用户线程。</p>
<p>这个过程大概是这样的，首先选择一些特定的执行位置，然后计算并保存这个位置的<strong>OopMap</strong>，这是可以预先完成的事情，然后当用户线程运行到这，让它停止，去扫描之前保存好的OopMap，扫描完成之后，放行用户线程。</p>
<p>所以为了GC，JAVA会在编译or类加载期间做一些额外的事情，分析每一段用户线程可能执行到的代码，选取一些位置，也称作<strong>安全点</strong>，为这些安全点生成OopMap，设置一个标志位，当线程执行到安全点代码时，读取标志位，判断当前是否需要GC，如果是，则自己挂起，等待其它线程挂起，当所有用户线程挂起之后，GC线程读取OopMap中的所有引用，并放进扫描集合，放行用户线程，进入<strong>并发标记</strong>阶段</p>
<h3 id="可达性分析中的并发（并发标记）"><a href="#可达性分析中的并发（并发标记）" class="headerlink" title="可达性分析中的并发（并发标记）"></a>可达性分析中的并发（并发标记）</h3><p>为了控制停顿时间，垃圾回收器在标记阶段需要和用户线程并发执行，当一个已经扫描的对象增加了新的引用，并且这个这个被引用的对象没有被其它未扫描到的对象引用时（或者原来有引用，但是被删除了），这个对象最后就被误认为垃圾回收掉，这是非常危险的</p>
<p>当以下两个条件同时被满足，会产生对象消失问题：</p>
<ul>
<li>赋值器插入了一条或多条从黑色对象到白色对象的新引用；</li>
<li>赋值器删除了全部从灰色对象到该白色对象的直接或间接引用。</li>
</ul>
<p>为了解决这个问题，有两种策略</p>
<ul>
<li>增量更新（Incremental Update）</li>
<li>原始快照（Snapshot At The Beginning，SATB）</li>
</ul>
<p><strong>增量更新</strong></p>
<p>关注第一个条件，为当黑色对象（已经扫过的对象）需要新增一条引用时，记录下来，等并发扫描结束后再扫一次，可以理解为当黑色对象新增一条引用，就把它变成灰色对象（已经被访问，但是引用还没扫完）</p>
<p><strong>原始快照</strong></p>
<p>关注第二个条件，当灰色或白色对象需要删除一条引用时，记录下来，在并发扫描结束后，再从这些被删除的引用出发扫描一次，也就是不把它当垃圾</p>
<p><strong>如果黑色对象在并发标记期间新增了一个引用，这个引用并不存在与灰色&#x2F;白色对象里，怎么处理？</strong></p>
<p>在增量更新的策略里，这种情况会被记录下来，结束后继续扫描。</p>
<p>在原始快照的策略里，不会记录这种情况，但是，会将所有并发标记中新建的对象标记为存活。</p>
<h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><ul>
<li><p><strong>标记-清除</strong></p>
<p>  扫一遍，垃圾对象标记为空闲内存</p>
<p>  缺点：内存碎片</p>
</li>
<li><p><strong>标记-整理</strong></p>
<p>  在标记-清除的基础上，移动存活的对象到内存的固定端，腾出整块的空闲内存</p>
<p>  缺点：费时间</p>
</li>
<li><p><strong>复制</strong></p>
<p>  把内存分成两半，每次只使用一半，每次gc把存活的对象复制到另一半，然后原来那一半整块都空闲了</p>
<p>  缺点：内存占用大，如果存活对象多，复制开销也大</p>
</li>
</ul>
<h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><p><img src="https://awps-assets.meituan.net/mit-x/blog-images-bundle-2016/8a9db36e.png" alt="传统GC内存布局"></p>
<h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a><strong>核心思想</strong></h3><p>大多数对象即用即弃，有些对象需要一直使用，如果每次GC都全堆扫描，那么难以达成吞吐量和性能的平衡。所以要给对象分区，一部分对象需要更频繁的GC，而另外一部分的不用</p>
<p>新生代：采用复制算法，当Eden区满时，触发一次minorGC，存活下来的对象放到幸存区，幸存区中的老对象则晋升到老年代</p>
<p>老年代：采用标记-清除或标记整理，当老年代空间不足，触发major GC或full GC</p>
<h3 id="跨代引用问题"><a href="#跨代引用问题" class="headerlink" title="跨代引用问题"></a><strong>跨代引用问题</strong></h3><p>当只针对一个区域的对象进行GC扫描时，无法分析到区域间的引用关系，比如新生代的某个对象A只被老年代的对象B引用，如果只扫新生代，A会被当成垃圾，但其实不应该回收。</p>
<p>那怎么办呢，难道再扫一次老年代吗，这违背了分代收集的初衷</p>
<p>采用记忆集来维护跨代引用关系，老年代的某个对象B如果要引用新生代的对象，那就把B添加到记忆集中，在扫描新生代时，把记忆集里的对象一起扫描了，记忆集的粒度不应该太小，不然内存成本大，也不应该太大，不然扫描成本大，把老年代分块，如果块内有对象引用了新生代，那么就在记忆集里标记一下这个块，扫描这个块里的所有对象</p>
<h2 id="并发整理"><a href="#并发整理" class="headerlink" title="并发整理"></a>并发整理</h2><p>G1收集器，只是在标记阶段不影响用户线程，但是在整理阶段也是需要暂停用户线程的。因为整理的过程中，存活对象的地址会变化，那么其它对象保存的这个引用是不一定有效的。</p>
<p>没有什么是加中间层不能解决的，如果有，那就再加一层</p>
<p>我们只要让 <strong>对象引用（指针）-&gt;对象物理地址</strong> 这个访问操作始终有效，ZGC采用<strong>染色指针+读屏障</strong>解决这个问题</p>
<p>相较于传统收集器把GC需要的信息放在对象头或者额外的、JVM层面的、数据结构中，ZGC大胆的将GC信息放在对象的指针（地址&#x2F;引用）里，牺牲了一部分的寻址空间，但获得了很多额外的好处</p>
<p>染色指针的结构</p>
<p><img src="/images/image-20250906145114266.png" alt="image-20250906145114266"></p>
<p>ZGC会给所有对象访问操作加一个读屏障，访问前检查remapped位</p>
<p>如果是0，说明对象指向的是旧地址，读屏障会触发慢速路径，去查转发表，把新地址搬过来，并把remapped置为1</p>
<p>如果是1，直接访问</p>
<p>这种旧地址在被访问时替换新地址的过程，被称为<strong>自愈（Self-Healing）</strong></p>
<p>总的来说，ZGC的清理过程可以分为三步</p>
<ul>
<li>并发标记：这里并没有什么创新，和G1，CMS这些差不多，不一样的是ZGC只会改指针的m1,m0位</li>
<li>并发预备重分配：全堆扫描，选定一批需要整理的页，预先在新页中分配位置，创建转发表</li>
<li>并发重分配：将对象从旧地址搬到新地址，更新转发表</li>
<li>并发重映射：也就是修复旧指针，由于读屏障的存在，这并不是一个需要特意去做的过程，在下一次GC扫描过程中，所有指针会自动修复</li>
</ul>
<h2 id="发展的里程碑"><a href="#发展的里程碑" class="headerlink" title="发展的里程碑"></a>发展的里程碑</h2><h3 id="Serial-系列"><a href="#Serial-系列" class="headerlink" title="Serial 系列"></a>Serial 系列</h3><p>分代的，单线程的，全程（GC线程运行时）STW的收集器，看起来很老旧落后，但是相较于其它的收集器，有更小的额外内存占用，因此，在用户桌面的应用场景以及流行的微服务，云原生场景中，仍有一席之地</p>
<h3 id="Parallel-系列"><a href="#Parallel-系列" class="headerlink" title="Parallel 系列"></a>Parallel 系列</h3><p>相较于Serial 系列，引入了多线程，也就是GC过程中，有多个GC线程一起工作，但这个过程仍然需要暂停用户线程，Parallel 还提供了一些调优参数，可以主动设置最大停顿时间和吞吐量</p>
<h3 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h3><p>相较于前辈，引入了<strong>并发标记</strong>，在标记阶段不需要暂停用户线程，并发标记完成之后为了修正结果（并发标记阶段产生的不一致问题），会有一次STW，然后就是清除，因为CMS用的是<strong>标记-清除</strong>算法，不会影响用户进程，所以这个阶段也是并发的。</p>
<p>由于它的标记-清除策略，会产生很多内存碎片，当内存碎片太多，新对象塞不下时，则会来一次Full GC，<strong>标记-整理</strong>全堆，造成长时间的停顿，这也是CMS饱受诟病的原因</p>
<h3 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h3><p>Oracle的一小步，GC发展的一大步，开创了基于Region的内存布局形式，全堆收集，引入停顿时间预测模型，支持用户自定义停顿时间，每次GC通过“贪心算法”选择最有价值的Region回收，随着不断迭代，现在的G1在各种场景下性能表现均优于CMS，已经成为新版本JDK中默认的收集器</p>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>GC的前沿成果，实现了<strong>并发整理</strong>，有着超低的延迟，相较于前辈是<strong>数量级</strong>的差异，同时，吞吐量也毫不逊色，尤其在JDK21中，ZGC还引入了分代收集，可以说是未来的方向。</p>
<p><img src="/images/image-20250914152829967.png" alt="image-20250914152829967"></p>
<p><img src="/images/image-20250914152855867.png" alt="image-20250914152855867"></p>
<p>上图来自<a target="_blank" rel="noopener" href="https://cr.openjdk.org/~pliden/slides/ZGC-Jfokus-2018.pdf">《The Z Garbage Collector：Low Latency GC for OpenJDK》</a>比较了三款收集器的吞吐量和延迟</p>


      

    </section>
    
      <section class='ArticleMeta'>
          <div>
            发布于&nbsp;
            <time datetime="2025-09-14T05:22:39.000Z" itemprop="datePublished">
              2025-09-14
            </time>
          </div>
          
      </section>
    
    
</article>

  
</div>

            <footer>
    <div>© 2025 - Pix </div>
    <div>
        <span>
            Powered by <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a>
        </span>
        ,
        <span>
            Theme - <a target="_blank" rel="noopener" href="https://github.com/nameoverflow/hexo-theme-icalm">Icalm</a>
        </span>
    </div>
</footer>

        </div>
    </div>
</div>

<script src="/js/pager/dist/singlepager.js"></script>

<script>
var sp = new Pager('data-pager-shell')

</script>
</body>
</html>